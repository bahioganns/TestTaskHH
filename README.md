# TestTaskHH

A directory for solving problems in order to apply for an interesting vacancy.

Каждая задача является самостоятельным модулем и не объединена с другими.
Внизу всегда можно увидеть демонстрационный пример и некоторые assert для проверки работоспособности кода. Для запуска требуется исключительно Python3.

## Task1: Odd or Even

Для выполнения данной задачи я реализовал 4 разных алгоритма определения четности числа.

1. **Использования оператора `%`**
   - **Плюсы**: Интуитивно понятный и общепринятый способ.
   - **Минусы**: На больших числах может быть медленным.

2. **Использование оператора `&`**
   - **Плюсы**: Самый быстрый способ, легко читаемый, эффективный.
   - **Минусы**: Может запутать.

3. **Использование оператора побитового сдвига `>>`**
   - **Плюсы**: Достаточно быстрый, медленнее 2, быстрее 1.
   - **Минусы**: Очень плохо читаем.

4. **Использование рекурсии**
   - **Плюсы**: Нет.
   - **Минусы**: Самый медленный, плохо читаем, может вызвать переполнение стека, избыточен.

## Task2: FIFO Buffer

1. **Использование list**:
   - **Плюсы**:
     - Просто реализовать.
     - Достаточно эффективен (в вакууме) по времени и памяти, так как использует встроенный в python list, однако хуже deque.
     - Подходит для фиксированного размера буфера.
   - **Минусы**:
     - Вставка и удаление элементов в начало списка неэффективны - O(n).
     - Расширение буфера будет неэффективным.

2. **Использование deque**:
   - **Плюсы**:
     - Deque лучше чем list оптимизирован для вставки и удаления с обоих концов, вставка и удаление выполняются за O(1).
     - Еще проще в реализации, чем list, легче расширить.
     - Интуитивный подход.
   - **Минусы**:
     - Решение может быть избыточным для простых задач.

## Task3: Best Sorting Algorithm

Если не считать встроенный в python `sort` и `sorted`, которые являются самыми эффективными благодаря алгоритму Timsort,
следующий самый эффективный алгоритм - merge sort. Он демонстрирует O(n log n) в хорошем, среднем и плохом случае, в
то время как quick sort демонстрирует O(n^2) в плохом случае. Любой другой алгоритм сортировки будет показывать результат
хуже, чем merge sort хотя бы в одном из этих случаев. Я реализовал алгоритм merge sort и добавил небольшую демонстрацию.
